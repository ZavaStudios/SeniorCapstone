using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MazeGeneration
{
    class Maze
    {
        // Width and height of the map, stored as global values to be used
        // in helper functions easily. Admittedly not the best design, but
        // it's by far the easiest setup for getting this to work.
        private static int _width;
        private static int _height;

        /// <summary>
        /// Generates a map for a maze in the form of a boolean grid.
        /// False indicates a wall, while true indicates a passageway.
        /// 
        /// The algorithm generates a maze of the provided width and
        /// height, but not in the intuitive sense. A maze consists of
        /// "room" and "wall" tiles. The room tiles occur every other
        /// row and column, and are guaranteed to be true in the final
        /// maze. Wall tiles are then every remaining tile. A maze will
        /// always have 2n+1 total grid elements in one direction, where
        /// n is the number of rooms in that direction.
        /// 
        /// Example:
        /// 
        /// - - - - - - - - - - -
        /// - x - x - x - x - x -
        /// - - - - - - - - - - -
        /// - x - x - x - x - x -
        /// - - - - - - - - - - -
        /// 
        /// The above map marks where rooms occur, versus where non-rooms
        /// do. The x's mark rooms, and the dashes are walls. We will say
        /// that this map is 5 rooms wide, and 2 rooms tall. These values
        /// (5 and 2) are what you would pass to this alogirthm as width
        /// and height.
        /// 
        /// All mazes generated by this algorithm will have walls around
        /// the outside, meaning the outer boundary is always false.
        /// Any remaining tiles can be any value, except that rooms will
        /// be true, and all rooms will be connected by some path in the
        /// maze.
        /// </summary>
        /// <param name="width">Number of rooms wide the maze should be</param>
        /// <param name="height">Number of rooms tall the maze should be</param>
        /// <returns>A (2 * width + 1) x (2 * height + 1) grid of booleans representing the map</returns>
        public static bool[,] GenerateMaze(int width, int height)
        {
            // Initialize the map
            _width = (2 * width) + 1;
            _height = (2 * height) + 1;
            bool[,] map = new bool[_width, _height];
            for (int x = 0; x < _width; x++)
            {
                for (int y = 0; y < _height; y++)
                {
                    map[x, y] = false;
                }
            }

            // Our random generator. :)
            Random r = new Random();

            // Start in room (0, 0). TODO: consider changing this to a random room
            int startX = (2 * 0) + 1;   // Yes, I know these computations are not necessary.
            int startY = (2 * 0) + 1;   // They'll get compiled out. Just making it clear we're starting
                                        // at the (0, 0) room.

            // Initialize our wall tracker with our starting room:
            LinkedList<Wall> wallList = new LinkedList<Wall>();
            map[startX, startY] = true;
            foreach (Wall wall in getAdjacentWalls(startX, startY))
                wallList.AddFirst(wall);

            // Until we run out of Walls, pull them out and try to add them to the maze:
            while (wallList.Count > 0)
            {
                // Pop a random wall off our wall tracker:
                Wall wall = wallList.ElementAt(r.Next(wallList.Count));
                wallList.Remove(wall);

                // Get coordinates for the adjacent room:
                int nextRoomX;
                int nextRoomY;
                travelThroughWall(wall, out nextRoomX, out nextRoomY);

                // If the corresponding room is not already in the maze, add this wall,
                // that room, and then put that room's adjacent walls into the list.
                if (!map[nextRoomX, nextRoomY])
                {
                    map[wall.X, wall.Y] = true;
                    map[nextRoomX, nextRoomY] = true;

                    foreach (Wall newWall in getAdjacentWalls(nextRoomX, nextRoomY))
                        wallList.AddFirst(newWall);
                }
            }

            // When we have finished that loop, our maze is complete!
            return map;
        }

        /// <summary>
        /// Returns a list of adjascent walls given a room's coordinates in the map.
        /// Excludes any walls that lie on the boundary of the map.
        /// </summary>
        /// <param name="x">X coordinate of the room in the map</param>
        /// <param name="y">Y coordinate of the room in the map</param>
        /// <returns>List of adjascent walls. May be empty, though that's unlikely.</returns>
        private static ICollection<Wall> getAdjacentWalls(int x, int y)
        {
            LinkedList<Wall> toRet = new LinkedList<Wall>();

            // Check: is this wall on the boundary of the map? If not, add it.
            if (x - 1 > 0)
                toRet.AddFirst(new Wall(x - 1, y, Wall.Direction.Left));
            if (x + 1 < _width - 1)
                toRet.AddFirst(new Wall(x + 1, y, Wall.Direction.Right));
            if (y - 1 > 0)
                toRet.AddFirst(new Wall(x, y - 1, Wall.Direction.Down));
            if (y + 1 < _height - 1)
                toRet.AddFirst(new Wall(x, y + 1, Wall.Direction.Up));

            return toRet;
        }

        /// <summary>
        /// Gets the coordinates of the room on the other side of the provided wall.
        /// Stores these coordinates in out parameters.
        /// </summary>
        /// <param name="wall">Wall to travel through</param>
        /// <param name="x">Contains the X coordinate of the opposite room after running</param>
        /// <param name="y">Contains the Y coordinate of the opposite room after running</param>
        private static void travelThroughWall(Wall wall, out int x, out int y)
        {
            switch (wall.Dir)
            {
                case Wall.Direction.Down:
                    x = wall.X;
                    y = wall.Y - 1;
                    break;
                case Wall.Direction.Left:
                    x = wall.X - 1;
                    y = wall.Y;
                    break;
                case Wall.Direction.Right:
                    x = wall.X + 1;
                    y = wall.Y;
                    break;
                case Wall.Direction.Up:
                default:
                    x = wall.X;
                    y = wall.Y + 1;
                    break;
            }
        }

        /// <summary>
        /// Helper class for generating a maze. Just a simple data set containing
        /// two pieces of data for the tile:
        ///     1) What position in the map this tile is located in.
        ///     2) In which direction we were traveling when accessing this wall.
        ///     
        /// The latter piece of information is useful, becuase we want to dig through
        /// to the next room when assigning the wall as inside the maze. This means,
        /// we need to determine where that room will be when we attempt to dig, and
        /// that requires the direction in which we are digging.
        /// </summary>
        private struct Wall
        {
            public enum Direction
            {
                Left, Up, Right, Down
            }

            /// <summary>
            /// X position of this wall in the map
            /// </summary>
            public int X
            {
                get;
                set;
            }
            /// <summary>
            /// Y position of this wall in the map
            /// </summary>
            public int Y
            {
                get;
                set;
            }
            /// <summary>
            /// Direction in which the algorithm is trying to travel through this wall.
            /// </summary>
            public Direction Dir
            {
                get;
                set;
            }

            /// <summary>
            /// Constructs a Wall, storing the necessary data.
            /// </summary>
            /// <param name="x">X position of the Wall in the map</param>
            /// <param name="y">Y position of the Wall in the map</param>
            /// <param name="dir">Direction in which you intend to travel through the Wall</param>
            public Wall(int x, int y, Direction dir) : this()
            {
                X = x;
                Y = y;
                Dir = dir;
            }

            public override string ToString()
            {
                return "(" + X + ", " + Y + ", " + Dir.ToString() + ")";
            }
        }
    }
}
